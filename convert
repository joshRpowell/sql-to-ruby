#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/inline'

gemfile do
  source 'https://rubygems.org'
  gem 'gda'
end

module Converter
  class Printer
    LINE_LENGTH = 80
    attr_reader :source, :clauses

    def initialize(source, clauses = [])
      @source = source
      @clauses = clauses
    end

    def <<(clause)
      clauses << clause
    end

    def print
      if source.length + clauses.sum(&:length) <= LINE_LENGTH
        "#{source}#{clauses.join}"
      else
        "#{source}#{clauses.map { |clause| "\n  #{clause}" }.join}"
      end
    end

    def self.print(source)
      instance = new(source)
      yield instance
      instance.print
    end
  end

  module Conversions
    refine GDA::Nodes::Expr do
      def convert
        if func
          func.convert
        elsif cond
          cond.convert
        elsif value
          value
        else
          raise 'Unsupported expression type'
        end
      end
    end

    refine GDA::Nodes::Function do
      def convert
        "#{function_name}(#{args_list.map(&:convert).join(', ')})"
      end
    end

    refine GDA::Nodes::Join do
      def convert(target)
        ".joins(:#{target.convert})"
      end
    end

    refine GDA::Nodes::Operation do
      def convert
        raise 'Cannot yet understand operators besides =' unless operator == '='
        left, right = operands.map(&:convert)
        "#{left}: \"#{right}\""
      end
    end

    refine GDA::Nodes::Order do
      def convert(source)
        if asc
          ":#{expr.convert}"
        else
          "#{source}.arel_table[#{expr.convert.to_sym.inspect}].desc"
        end
      end
    end

    refine GDA::Nodes::Select do
      def convert
        source = from.targets[0].convert[0...-1].capitalize

        Printer.print(source) do |printer|
          if expr_list.length > 1 || expr_list[0].expr.value != '*'
            printer << ".select(#{expr_list.map { |node| node.convert(source) }.join(', ')})"
          elsif from.targets.length == 1 && !where_cond && order_by.length == 0 && !limit_count && !limit_offset
            printer << '.all'
          end

          if from.targets.length > 0
            from.joins.zip(from.targets[1..-1]).each do |join, target|
              printer << join.convert(target)
            end
          end

          printer << ".where(#{where_cond.convert})" if where_cond

          if order_by.length > 0
            printer << ".order(#{order_by.map { |node| node.convert(source) }.join(', ')})"
          end

          printer << ".limit(#{limit_count.convert})" if limit_count
          printer << ".offset(#{limit_offset.convert})" if limit_offset
        end
      end
    end

    refine GDA::Nodes::SelectField do
      def convert(source)
        if field_name
          symbol = field_name.to_sym.inspect
          as ? "#{source}.arel_table[#{symbol}].as(#{as})" : symbol
        else
          field = "Arel.sql(\"#{expr.convert}\")"
          as ? "#{field}.as(\"#{as}\")" : field
        end
      end
    end

    refine GDA::Nodes::Target do
      def convert
        table_name
      end
    end

    refine GDA::Nodes::Unknown do
      def convert
        'Error parsing'
      end
    end
  end

  using Conversions

  def self.convert(sql)
    GDA::SQL::Parser.new.parse(sql).ast.convert
  end
end

puts Converter.convert(ARGV.first)
